/*
 * Copyright (c) 2022, YuzukiTsuru <GloomyGhost@GloomyGhost.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 *
 * See README and LICENSE for more details.
 */

//
// Created by gloom on 2022/9/23.
//

#include "d1.h"

d1::d1(class fel *f, chip_version_t chip_version) : Chips(f, chip_version) {
    chip_info.chip_name = "D1-H/D1s/F133-A/F133-B/R528-RV";
    chip_info.chip_id = 0x00185900;
    chip_info.chip_type = chip_type_e::Heterogeneous;
    chip_info.chip_core = core_name_.XuantieC906;
    chip_info.chip_core_count = 1;
    chip_info.chip_core_count_str = core_count_.core_count_1;
    chip_info.chip_heterogeneous_core.push_back("HIFI4");
}

chip_function_e d1::chip_detect() {
    if (chip_info.chip_version.id == chip_info.chip_id) {
        // Check 0 addr is 0x43014281, RISC-V
        if (fel_->fel_read32(0x00000000) == 0x43014281)
            return chip_function_e::Success;
    }
    return chip_function_e::Fail;
}

chip_function_e d1::chip_reset() {
    fel_->fel_write32(0x020500a0 + 0x08, (0x16aa << 16) | (0x1 << 0));
    return chip_function_e::Success;
}

chip_function_e d1::chip_sid() {
    const uint8_t payload[] = {
            0x37, 0x03, 0x40, 0x00, 0x73, 0x20, 0x03, 0x7c, 0x37, 0x03, 0x03, 0x00,
            0x1b, 0x03, 0x33, 0x01, 0x73, 0x20, 0x23, 0x7c, 0x6f, 0x00, 0x40, 0x00,
            0x13, 0x01, 0x01, 0xfe, 0x23, 0x34, 0x81, 0x00, 0x23, 0x38, 0x91, 0x00,
            0x23, 0x3c, 0x11, 0x00, 0x13, 0x04, 0x05, 0x00, 0x37, 0x15, 0x02, 0x00,
            0xef, 0x00, 0x00, 0x02, 0x83, 0x30, 0x81, 0x01, 0x03, 0x34, 0x81, 0x00,
            0x83, 0x34, 0x01, 0x01, 0x13, 0x01, 0x01, 0x02, 0x67, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x67, 0x00, 0x03,
            0x03, 0xa7, 0x07, 0x20, 0x23, 0x20, 0xe5, 0x00, 0x03, 0xa7, 0x47, 0x20,
            0x23, 0x22, 0xe5, 0x00, 0x03, 0xa7, 0x87, 0x20, 0x23, 0x24, 0xe5, 0x00,
            0x83, 0xa7, 0xc7, 0x20, 0x23, 0x26, 0xf5, 0x00, 0x67, 0x80, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    uint32_t id[4];

    fel_->fel_write(0x00020000, &payload[0], sizeof(payload));
    fel_->fel_exec(0x00020000);
    fel_->fel_read(0x00021000, id, sizeof(id));

    chip_info.chip_sid = "";
    for (const uint32_t &j: id) {
        chip_info.chip_sid.append(QString::number(j, 16));
    }
    return chip_function_e::Success;
}

chip_function_e d1::chip_jtag() {
    const uint8_t payload[] = {
            0x37, 0x03, 0x40, 0x00, 0x73, 0x20, 0x03, 0x7c, 0x37, 0x03, 0x03, 0x00,
            0x1b, 0x03, 0x33, 0x01, 0x73, 0x20, 0x23, 0x7c, 0x6f, 0x00, 0x40, 0x00,
            0x13, 0x01, 0x01, 0xfe, 0x23, 0x34, 0x81, 0x00, 0x23, 0x38, 0x91, 0x00,
            0x23, 0x3c, 0x11, 0x00, 0x13, 0x04, 0x05, 0x00, 0xef, 0x00, 0x40, 0x02,
            0x83, 0x30, 0x81, 0x01, 0x03, 0x34, 0x81, 0x00, 0x83, 0x34, 0x01, 0x01,
            0x13, 0x01, 0x01, 0x02, 0x67, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x07, 0x00, 0x02,
            0x03, 0xa7, 0x07, 0x0f, 0xb7, 0x16, 0xff, 0xff, 0x93, 0x86, 0xf6, 0xff,
            0x13, 0x77, 0x07, 0xff, 0x13, 0x67, 0x47, 0x00, 0x23, 0xa8, 0xe7, 0x0e,
            0x03, 0xa7, 0x07, 0x0f, 0x13, 0x77, 0xf7, 0xf0, 0x13, 0x67, 0x07, 0x04,
            0x23, 0xa8, 0xe7, 0x0e, 0x03, 0xa7, 0x07, 0x0f, 0x33, 0x77, 0xd7, 0x00,
            0xb7, 0x46, 0x00, 0x00, 0x33, 0x67, 0xd7, 0x00, 0x23, 0xa8, 0xe7, 0x0e,
            0x03, 0xa7, 0x07, 0x0f, 0xb7, 0x06, 0x10, 0xff, 0x93, 0x86, 0xf6, 0xff,
            0x33, 0x77, 0xd7, 0x00, 0xb7, 0x06, 0x40, 0x00, 0x33, 0x67, 0xd7, 0x00,
            0x23, 0xa8, 0xe7, 0x0e, 0x67, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };
    fel_->fel_write(0x00020000, &payload[0], sizeof(payload));
    fel_->fel_exec(0x00020000);
    return chip_function_e::Success;
}

chip_function_e d1::chip_ddr(chip_ddr_type_e dram_type) {
    if (dram_type == chip_ddr_type_e::DDR3) {
        const dram_param_t ddr3 = {
                .dram_clk = 792,
                .dram_type = 3,
                .dram_zq = 0x7b7bfb,
                .dram_odt_en = 0x01,
                .dram_para1 = 0x000010d2,
                .dram_para2 = 0x0000,
                .dram_mr0 = 0x1c70,
                .dram_mr1 = 0x042,
                .dram_mr2 = 0x18,
                .dram_mr3 = 0x0,
                .dram_tpr0 = 0x004A2195,
                .dram_tpr1 = 0x02423190,
                .dram_tpr2 = 0x0008B061,
                .dram_tpr3 = 0xB4787896,
                .dram_tpr4 = 0x0,
                .dram_tpr5 = 0x48484848,
                .dram_tpr6 = 0x00000048,
                .dram_tpr7 = 0x1620121e,
                .dram_tpr8 = 0x0,
                .dram_tpr9 = 0x0,
                .dram_tpr10 = 0x0,
                .dram_tpr11 = 0x00870000,
                .dram_tpr12 = 0x00000024,
                .dram_tpr13 = 0x34050100,
        };
        fel_->fel_write(0x00020000, &ddr3_dram_payload[0], sizeof(ddr3_dram_payload));
        fel_->fel_write(0x00020018, &ddr3, sizeof(ddr3));
        fel_->fel_exec(0x00020000);
        return chip_function_e::Success;
    } else if (dram_type == chip_ddr_type_e::DDR2) {
        const dram_param_t ddr2 = {
                .dram_clk = 528,
                .dram_type = 2,
                .dram_zq = 0x07b7bf9,
                .dram_odt_en = 0x00,
                .dram_para1 = 0x000000d2,
                .dram_para2 = 0x00000000,
                .dram_mr0 = 0x00000e73,
                .dram_mr1 = 0x02,
                .dram_mr2 = 0x0,
                .dram_mr3 = 0x0,
                .dram_tpr0 = 0x00471992,
                .dram_tpr1 = 0x0131a10c,
                .dram_tpr2 = 0x00057041,
                .dram_tpr3 = 0xb4787896,
                .dram_tpr4 = 0x0,
                .dram_tpr5 = 0x48484848,
                .dram_tpr6 = 0x48,
                .dram_tpr7 = 0x1621121e,
                .dram_tpr8 = 0x0,
                .dram_tpr9 = 0x0,
                .dram_tpr10 = 0x00000000,
                .dram_tpr11 = 0x00030010,
                .dram_tpr12 = 0x00000035,
                .dram_tpr13 = 0x34000000,
        };
        fel_->fel_write(0x00020000, &ddr2_dram_payload[0], sizeof(ddr2_dram_payload));
        fel_->fel_write(0x00020018, &ddr2, sizeof(ddr2));
        fel_->fel_exec(0x00020000);
        return chip_function_e::Success;
    }
    return chip_function_e::NotSupport;
}

chip_function_e d1::chip_ddr(dram_param_t param) {
    if (param.dram_type == chip_ddr_type_e::DDR2) {
        fel_->fel_write(0x00020000, &ddr2_dram_payload[0], sizeof(ddr2_dram_payload));
    } else if (param.dram_type == chip_ddr_type_e::DDR3) {
        fel_->fel_write(0x00020000, &ddr3_dram_payload[0], sizeof(ddr3_dram_payload));
    } else {
        return chip_function_e::NotSupport;
    }
    fel_->fel_write(0x00020018, &param, sizeof(param));
    fel_->fel_exec(0x00020000);
    return chip_function_e::Success;
}

chip_function_e d1::chip_spi_init(uint32_t *swap_buf, uint32_t *swap_len, uint32_t *cmd_len) {
    return chip_function_e::NotSupport;
}

chip_function_e d1::chip_spi_run(uint8_t *cbuf, uint32_t clen) {
    return chip_function_e::NotSupport;
}